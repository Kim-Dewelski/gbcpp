#include<disassemble/disassemble.h>
#include<stdexcept>
#include<sstream>
#include<iomanip>
#include<cstring>

std::array<const char*,256> disassembler_t::noncb_mnemonic = {
    "nop",
    "ld BC, %1",
    "ld (BC), A",
    "inc BC",
    "inc B",
    "dec B",
    "ld B, %1",
    "rlca",
    "ld (%2), SP",
    "add HL, BC",
    "ld A, (BC)",
    "dec BC",
    "inc C",
    "dec C",
    "ld C, %1",
    "rrca",
    "stop",
    "ld DE, %2",
    "ld (DE), A",
    "inc DE",
    "inc D",
    "dec D",
    "ld D, %1",
    "rla",
    "jr %-",
    "add HL, DE",
    "ld A, (DE)",
    "dec DE",
    "inc E",
    "dec E",
    "ld E, %1",
    "RRA",
    "jr nz, %-",
    "ld HL, %2",
    "ld (HL+), A",
    "inc HL",
    "inc H",
    "dec H",
    "ld H, %1",
    "daa",
    "jr z, %-",
    "add HL, HL",
    "ld A, (HL+)",
    "dec HL",
    "inc L",
    "dec L",
    "ld L, %1",
    "cpl",
    "jr nc, %-",
    "ld sp, %2",
    "ld (hl-), A",
    "inc SP",
    "inc (HL)",
    "dec (HL)",
    "ld (HL), %1",
    "scf",
    "jr c, %-",
    "add HL, SP",
    "ld A, (HL-)",
    "dec SP",
    "inc A",
    "dec A",
    "ld A, %1",
    "ccf",
    "ld B, B",
    "ld B, C",
    "ld B, D",
    "ld B, E",
    "ld B, H",
    "ld B, L",
    "ld B, (HL)",
    "ld B, A",
    "ld C, B",
    "ld C, C",
    "ld C, D",
    "ld C, E",
    "ld C, H",
    "ld C, L",
    "ld C, (HL)",
    "ld C, A",
    "ld D, B",
    "ld D, C",
    "ld D, D",
    "ld D, E",
    "ld D, H",
    "ld D, L",
    "ld D, (HL)",
    "ld D, A",
    "ld E, B",
    "ld E, C",
    "ld E, D",
    "ld E, E",
    "ld E, H",
    "ld E, L",
    "ld E, (HL)",
    "ld E, A",
    "ld H, B",
    "ld H, C",
    "ld H, D",
    "ld H, E",
    "ld H, H",
    "ld H, L",
    "ld H, (HL)",
    "ld H, A",
    "ld L, B",
    "ld L, C",
    "ld L, D",
    "ld L, E",
    "ld L, H",
    "ld L, L",
    "ld L, (HL)",
    "ld L, A",
    "ld (HL), B",
    "ld (HL), C",
    "ld (HL), D",
    "ld (HL), E",
    "ld (HL), H",
    "ld (HL), L",
    "halt",
    "ld (HL), A",
    "ld A, B",
    "ld A, C",
    "ld A, D",
    "ld A, E",
    "ld A, H",
    "ld A, L",
    "ld A, (HL)",
    "ld A, A",
    "add A, B",
    "add A, C",
    "add A, D",
    "add A, E",
    "add A, H",
    "add A, L",
    "add A, (HL)",
    "add A, A",
    "adc A, B",
    "adc A, C",
    "adc A, D",
    "adc A, E",
    "adc A, H",
    "adc A, L",
    "adc A, (HL)",
    "adc A, A",
    "sub A, B",
    "sub A, C",
    "sub A, D",
    "sub A, E",
    "sub A, H",
    "sub A, L",
    "sub A, (HL)",
    "sub A, A",
    "sbc A, B",
    "sbc A, C",
    "sbc A, D",
    "sbc A, E",
    "sbc A, H",
    "sbc A, L",
    "sbc A, (HL)",
    "sbc A, A",
    "and A, B",
    "and A, C",
    "and A, D",
    "and A, E",
    "and A, H",
    "and A, L",
    "and A, (HL)",
    "and A, A",
    "xor A, B",
    "xor A, C",
    "xor A, D",
    "xor A, E",
    "xor A, H",
    "xor A, L",
    "xor A, (HL)",
    "xor A, A",
    "or A, B",
    "or A, C",
    "or A, D",
    "or A, E",
    "or A, H",
    "or A, L",
    "or A, (HL)",
    "or A, A",
    "cp A, B",
    "cp A, C",
    "cp A, D",
    "cp A, E",
    "cp A, H",
    "cp A, L",
    "cp A, (HL)",
    "cp A, A",
    "ret nz",
    "pop BC",
    "jp nz, %2",
    "jp %2",
    "call nz, %2",
    "push BC",
    "add A, %1",
    "rst 00h",
    "ret z",
    "ret",
    "jp z, %2",
    "prefix cb",
    "call z, %2",
    "call %2",
    "adc A, %1",
    "rst 08h",
    "ret nz",
    "pop bc",
    "jp nc, %2",
    "n/a",
    "call nc, %2",
    "push DE",
    "sub A, %1",
    "rst 10h",
    "ret c",
    "reti",
    "jp c, %2",
    "n/a",
    "call c, %2",
    "n/a",
    "sbc a, %1",
    "rst 18h",
    "ldh (%1), A",
    "pop HL",
    "ldh (C), A",
    "n/a",
    "n/a",
    "push HL",
    "and A, %1",
    "rst 20h",
    "add SP, %-",
    "jp HL",
    "ld (%2),A",
    "n/a",
    "n/a",
    "n/a",
    "xor a, %1",
    "rst 28h",
    "ldh A, (%1)",
    "pop AF",
    "ldh A, (C)",
    "di",
    "n/a",
    "push AF",
    "or A, %1",
    "rst 30h",
    "ld HL, SP+%-",
    "ld SP, HL",
    "ld A, (%2)",
    "EI",
    "n/a",
    "n/a",
    "cp A, %1",
    "rst 38h"
};
std::array<const char*,256> disassembler_t::cb_mnemonic = {
    "rlc B",
    "rlc C",
    "rlc D",
    "rlc E",
    "rlc H",
    "rlc L",
    "rlc (HL)",
    "rlc A",
    "rrc B",
    "rrc C",
    "rrc D",
    "rrc E",
    "rrc H",
    "rrc L",
    "rrc (HL)",
    "rrc A",
    "rl B",
    "rl C",
    "rl D",
    "rl E",
    "rl H",
    "rl L",
    "rl (HL)",
    "rl A",
    "rr B",
    "rr C",
    "rr D",
    "rr E",
    "rr H",
    "rr L",
    "rr (HL)",
    "rr A",
    "sla B",
    "sla C",
    "sla D",
    "sla E",
    "sla H",
    "sla L",
    "sla (HL)",
    "sla A",
    "sra B",
    "sra C",
    "sra D",
    "sra E",
    "sra H",
    "sra L",
    "sra (HL)",
    "sra A",
    "swap B",
    "swap C",
    "swap D",
    "swap E",
    "swap H",
    "swap L",
    "swap (HL)",
    "swap A",
    "srl B",
    "srl C",
    "srl D",
    "srl E",
    "srl H",
    "srl L",
    "srl (HL)",
    "srl A",
    "bit 0, B",
    "bit 0, C",
    "bit 0, D",
    "bit 0, E",
    "bit 0, H",
    "bit 0, L",
    "bit 0, (HL)",
    "bit 0, A",
    "bit 1, B",
    "bit 1, C",
    "bit 1, D",
    "bit 1, E",
    "bit 1, H",
    "bit 1, L",
    "bit 1, (HL)",
    "bit 1, A",
    "bit 2, B",
    "bit 2, C",
    "bit 2, D",
    "bit 2, E",
    "bit 2, H",
    "bit 2, L",
    "bit 2, (HL)",
    "bit 2, A",
    "bit 3, B",
    "bit 3, C",
    "bit 3, D",
    "bit 3, E",
    "bit 3, H",
    "bit 3, L",
    "bit 3, (HL)",
    "bit 3, A",
    "bit 4, B",
    "bit 4, C",
    "bit 4, D",
    "bit 4, E",
    "bit 4, H",
    "bit 4, L",
    "bit 4, (HL)",
    "bit 4, A",
    "bit 5, B",
    "bit 5, C",
    "bit 5, D",
    "bit 5, E",
    "bit 5, H",
    "bit 5, L",
    "bit 5, (HL)",
    "bit 5, A",
    "bit 6, B",
    "bit 6, C",
    "bit 6, D",
    "bit 6, E",
    "bit 6, H",
    "bit 6, L",
    "bit 6, (HL)",
    "bit 6, A",
    "bit 7, B",
    "bit 7, C",
    "bit 7, D",
    "bit 7, E",
    "bit 7, H",
    "bit 7, L",
    "bit 7, (HL)",
    "bit 7, A",
    "res 0, B",
    "res 0, C",
    "res 0, D",
    "res 0, E",
    "res 0, H",
    "res 0, L",
    "res 0, (HL)",
    "res 0, A",
    "res 1, B",
    "res 1, C",
    "res 1, D",
    "res 1, E",
    "res 1, H",
    "res 1, L",
    "res 1, (HL)",
    "res 1, A",
    "res 2, B",
    "res 2, C",
    "res 2, D",
    "res 2, E",
    "res 2, H",
    "res 2, L",
    "res 2, (HL)",
    "res 2, A",
    "res 3, B",
    "res 3, C",
    "res 3, D",
    "res 3, E",
    "res 3, H",
    "res 3, L",
    "res 3, (HL)",
    "res 3, A",
    "res 4, B",
    "res 4, C",
    "res 4, D",
    "res 4, E",
    "res 4, H",
    "res 4, L",
    "res 4, (HL)",
    "res 4, A",
    "res 5, B",
    "res 5, C",
    "res 5, D",
    "res 5, E",
    "res 5, H",
    "res 5, L",
    "res 5, (HL)",
    "res 5, A",
    "res 6, B",
    "res 6, C",
    "res 6, D",
    "res 6, E",
    "res 6, H",
    "res 6, L",
    "res 6, (HL)",
    "res 6, A",
    "res 7, B",
    "res 7, C",
    "res 7, D",
    "res 7, E",
    "res 7, H",
    "res 7, L",
    "res 7, (HL)",
    "res 7, A",
    "set 0, B",
    "set 0, C",
    "set 0, D",
    "set 0, E",
    "set 0, H",
    "set 0, L",
    "set 0, (HL)",
    "set 0, A",
    "set 1, B",
    "set 1, C",
    "set 1, D",
    "set 1, E",
    "set 1, H",
    "set 1, L",
    "set 1, (HL)",
    "set 1, A",
    "set 2, B",
    "set 2, C",
    "set 2, D",
    "set 2, E",
    "set 2, H",
    "set 2, L",
    "set 2, (HL)",
    "set 2, A",
    "set 3, B",
    "set 3, C",
    "set 3, D",
    "set 3, E",
    "set 3, H",
    "set 3, L",
    "set 3, (HL)",
    "set 3, A",
    "set 4, B",
    "set 4, C",
    "set 4, D",
    "set 4, E",
    "set 4, H",
    "set 4, L",
    "set 4, (HL)",
    "set 4, A",
    "set 5, B",
    "set 5, C",
    "set 5, D",
    "set 5, E",
    "set 5, H",
    "set 5, L",
    "set 5, (HL)",
    "set 5, A",
    "set 6, B",
    "set 6, C",
    "set 6, D",
    "set 6, E",
    "set 6, H",
    "set 6, L",
    "set 6, (HL)",
    "set 6, A",
    "set 7, B",
    "set 7, C",
    "set 7, D",
    "set 7, E",
    "set 7, H",
    "set 7, L",
    "set 7, (HL)",
    "set 7, A"
};
std::array<bool,256> disassembler_t::labelify_table = {
//       0     1     2     3          4     5     6     7            8     9     A     B           C     D     E     F       
/*0*/    false,false,false,false,     false,false,false,false,       false,false,false,false,      false,false,false,false,
/*1*/    false,false,false,false,     false,false,false,false,       true,false,false,false,       false,false,false,false,
/*2*/    true,false,false,false,      false,false,false,false,       true,false,false,false,       false,false,false,false,
/*3*/    true,false,false,false,      false,false,false,false,       true,false,false,false,       false,false,false,false,

/*4*/    false,false,false,false,     false,false,false,false,       false,false,false,false,      false,false,false,false,
/*5*/    false,false,false,false,     false,false,false,false,       false,false,false,false,      false,false,false,false,
/*6*/    false,false,false,false,     false,false,false,false,       false,false,false,false,      false,false,false,false,
/*7*/    false,false,false,false,     false,false,false,false,       false,false,false,false,      false,false,false,false,

/*8*/    false,false,false,false,     false,false,false,false,       false,false,false,false,      false,false,false,false,
/*9*/    false,false,false,false,     false,false,false,false,       false,false,false,false,      false,false,false,false,
/*A*/    false,false,false,false,     false,false,false,false,       false,false,false,false,      false,false,false,false,
/*B*/    false,false,false,false,     false,false,false,false,       false,false,false,false,      false,false,false,false,

/*C*/    false,false,true,true,       true,false,false,true,         false,false,true,false,       true,true,false,true,
/*D*/    false,false,true,false,      true,false,false,true,         false,false,true,false,       true,false,false,true,
/*E*/    false,false,false,false,     false,false,false,true,        false,false,false,false,      false,false,false,true,
/*F*/    false,false,false,false,     false,false,false,true,        false,false,false,false,      false,false,false,true
};

std::array<bool,256> disassembler_t::ret_table = {
//       0     1     2     3          4     5     6     7            8     9     A     B           C     D     E     F       
/*0*/    false,false,false,false,     false,false,false,false,       false,false,false,false,      false,false,false,false,
/*1*/    false,false,false,false,     false,false,false,false,       false,false,false,false,      false,false,false,false,
/*2*/    false,false,false,false,     false,false,false,false,       false,false,false,false,      false,false,false,false,
/*3*/    false,false,false,false,     false,false,false,false,       false,false,false,false,      false,false,false,false,

/*4*/    false,false,false,false,     false,false,false,false,       false,false,false,false,      false,false,false,false,
/*5*/    false,false,false,false,     false,false,false,false,       false,false,false,false,      false,false,false,false,
/*6*/    false,false,false,false,     false,false,false,false,       false,false,false,false,      false,false,false,false,
/*7*/    false,false,false,false,     false,false,false,false,       false,false,false,false,      false,false,false,false,

/*8*/    false,false,false,false,     false,false,false,false,       false,false,false,false,      false,false,false,false,
/*9*/    false,false,false,false,     false,false,false,false,       false,false,false,false,      false,false,false,false,
/*A*/    false,false,false,false,     false,false,false,false,       false,false,false,false,      false,false,false,false,
/*B*/    false,false,false,false,     false,false,false,false,       false,false,false,false,      false,false,false,false,

/*C*/    true,false,false,false,     false,false,false,false,        true,true,false,false,        false,false,false,false,
/*D*/    true,false,false,false,     false,false,false,false,        true,true,false,false,        false,false,false,false,
/*E*/    false,false,false,false,    false,false,false,false,        false,false,false,false,      false,false,false,false,
/*F*/    false,false,false,false,    false,false,false,false,        false,false,false,false,      false,false,false,false
};

std::array<bool,256> disassembler_t::call_table = {
//       0     1     2     3          4     5     6     7            8     9     A     B           C     D     E     F       
/*0*/    false,false,false,false,     false,false,false,false,       false,false,false,false,      false,false,false,false,
/*1*/    false,false,false,false,     false,false,false,false,       false,false,false,false,      false,false,false,false,
/*2*/    false,false,false,false,     false,false,false,false,       false,false,false,false,      false,false,false,false,
/*3*/    false,false,false,false,     false,false,false,false,       false,false,false,false,      false,false,false,false,

/*4*/    false,false,false,false,     false,false,false,false,       false,false,false,false,      false,false,false,false,
/*5*/    false,false,false,false,     false,false,false,false,       false,false,false,false,      false,false,false,false,
/*6*/    false,false,false,false,     false,false,false,false,       false,false,false,false,      false,false,false,false,
/*7*/    false,false,false,false,     false,false,false,false,       false,false,false,false,      false,false,false,false,

/*8*/    false,false,false,false,     false,false,false,false,       false,false,false,false,      false,false,false,false,
/*9*/    false,false,false,false,     false,false,false,false,       false,false,false,false,      false,false,false,false,
/*A*/    false,false,false,false,     false,false,false,false,       false,false,false,false,      false,false,false,false,
/*B*/    false,false,false,false,     false,false,false,false,       false,false,false,false,      false,false,false,false,

/*C*/    false,false,false,false,     true,false,false,false,        false,false,false,false,      true,true,false,false,
/*D*/    false,false,false,false,     true,false,false,false,        false,false,false,false,      true,false,false,false,
/*E*/    false,false,false,false,     false,false,false,false,       false,false,false,false,      false,false,false,false,
/*F*/    false,false,false,false,     false,false,false,false,       false,false,false,false,      false,false,false,false
};

std::string disassembler_t::disassemble(uint8_t opc, uint16_t offset, uint16_t imm){
    if(opc != 0xCB){
        std::stringstream sstr;
        std::string str = noncb_mnemonic[opc];
        if(size_t pos = str.find('%'); pos != std::string::npos){
            char arg = str[pos+1];
            str.erase(pos,2);
            if(arg == '1'){
                std::string insert = "";
                if(labelify_table[opc])
                    insert = std::move(labelify_opc(opc, offset, imm));
                else{
                    sstr << std::hex << std::setfill('0') << std::setw(2) << std::uppercase << (imm&0xFF) << "h";
                    insert = sstr.str();
                }
                str.insert(pos, insert);
            } else if(arg == '2'){
                std::string insert = "";
                if(labelify_table[opc])
                    insert = std::move(labelify_opc(opc, offset, imm));
                else{
                    sstr << std::hex << std::setfill('0') << std::setw(4) << std::uppercase << imm << "h";
                    insert = sstr.str();
                }
                str.insert(pos, insert);
            } else if(arg == '-'){
                std::string insert = "";
                if(labelify_table[opc])
                    insert = std::move(labelify_opc(opc, offset, imm));
                else
                    insert = std::to_string(static_cast<int8_t>(imm));
                str.insert(pos, insert);
            } else{
                std::runtime_error("error disassembling. Improper string formatting.");
            }
        }
        return str;
    } else{
        return cb_mnemonic[imm&0xFF];
    }
}

std::string disassembler_t::labelify_opc(uint8_t opc, uint16_t offset, uint16_t imm){
    uint16_t adr = 0;
    if(
        opc == 0x18 ||
        opc == 0x28 ||
        opc == 0x38 ||
        opc == 0x20 ||
        opc == 0x30
    ){
        adr = offset+static_cast<int8_t>(imm);
    } else 
        adr = imm;
    if(!labels.contains(adr)){
        std::stringstream sstr;
        sstr << std::hex << std::setfill('0') << std::setw(4) << std::uppercase << adr << "h";
        labels[adr] = static_cast<std::string>("adr_")+sstr.str();
    }
    return labels[adr];
}

uint16_t disassembler_t::get_branch_results(uint8_t opc, uint16_t offset, uint16_t imm){
    if(!is_noncb_branch(opc))
        throw std::runtime_error("tried to get branch results from non-branchable instruction");
    if(
        opc == 0x18 ||
        opc == 0x28 ||
        opc == 0x38 ||
        opc == 0x20 ||
        opc == 0x30
    ){
        return offset+static_cast<int8_t>(imm);
    } else{
        return imm;
    }
}

bool disassembler_t::is_call(uint8_t opc){
    return call_table[opc];
}

bool disassembler_t::is_ret(uint8_t opc){
    return ret_table[opc];
}